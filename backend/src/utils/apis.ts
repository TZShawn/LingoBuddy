import axios from 'axios';
import OpenAI from 'openai';

const DEEPGRAM_API_URL = 'https://api.deepgram.com/v1/listen';
const ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1/text-to-speech';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Deepgram API
export async function transcribeAudio(audioBase64: string, language: string): Promise<string> {
  const audioBuffer = Buffer.from(audioBase64, 'base64');
  
  const response = await axios.post(
    `${DEEPGRAM_API_URL}?model=nova-2&language=${language}&smart_format=true`,
    audioBuffer,
    {
      headers: {
        'Authorization': `Token ${process.env.DEEPGRAM_API_KEY}`,
        'Content-Type': 'audio/wav',
      },
    }
  );

  const transcript = response.data.results?.channels?.[0]?.alternatives?.[0]?.transcript;
  if (!transcript) {
    throw new Error('No transcript found in Deepgram response');
  }

  return transcript;
}

// OpenAI API
export async function chatGenerateResponse(
  userMessage: string,
  language: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = []
): Promise<string> {
  const systemPrompt = `You are a helpful language learning assistant. The user is practicing ${language}. 
  Respond naturally in ${language} and help them improve their language skills. 
  If they make mistakes, gently correct them. Keep responses conversational and encouraging.`;

  const messages = [
    { role: 'system' as const, content: systemPrompt },
    ...conversationHistory,
    { role: 'user' as const, content: userMessage }
  ];

  const response = await openai.chat.completions.create({
    model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
    messages,
    max_tokens: 200,
    temperature: 0.7,
  });

  const aiResponse = response.choices?.[0]?.message?.content;
  if (!aiResponse) {
    throw new Error('No response generated by OpenAI');
  }

  return aiResponse;
}

// 11Labs API
export async function textToSpeech(text: string, voiceId?: string): Promise<string> {
  const voice = voiceId || process.env.ELEVENLABS_VOICE_ID || 'pNInz6obpgDQGcFmaJgB';
  
  const response = await axios.post(
    `${ELEVENLABS_API_URL}/${voice}`,
    {
      text,
      model_id: 'eleven_monolingual_v1',
      voice_settings: {
        stability: 0.5,
        similarity_boost: 0.5,
      },
    },
    {
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': process.env.ELEVENLABS_API_KEY!,
      },
      responseType: 'arraybuffer',
    }
  );

  return Buffer.from(response.data).toString('base64');
}

// OpenAI Translation API
export async function translateWord(
  word: string,
  sourceLanguage: string,
  targetLanguage: string
): Promise<{ translatedWord: string; partOfSpeech?: string; confidence?: number }> {
  try {
    const languageNames = {
      'en': 'English',
      'es': 'Spanish', 
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese'
    };

    const sourceLangName = languageNames[sourceLanguage as keyof typeof languageNames] || sourceLanguage;
    const targetLangName = languageNames[targetLanguage as keyof typeof languageNames] || targetLanguage;

    const prompt = `Translate the word "${word}" from ${sourceLangName} to ${targetLangName}. 
    Return ONLY a JSON object with this exact structure:
    {
      "translatedWord": "translation",
      "partOfSpeech": "noun/verb/adjective/etc",
      "confidence": 0.95
    }
    
    Be concise and accurate. If the word has multiple meanings, provide the most common one.`;

    const response = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 100,
      temperature: 0.1, // Low temperature for consistent results
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response generated by OpenAI');
    }

    // Parse the JSON response
    const translation = JSON.parse(content);
    return {
      translatedWord: translation.translatedWord,
      partOfSpeech: translation.partOfSpeech,
      confidence: translation.confidence || 0.9,
    };
  } catch (error) {
    console.error('Translation error:', error);
    throw new Error('Failed to translate word');
  }
}

// OpenAI Text Splitting and Translation API
export async function splitAndTranslateText(
  text: string,
  sourceLanguage: string,
  targetLanguage: string
): Promise<{
  segments: Array<{
    text: string;
    translation: string;
    hoverable: boolean;
    partOfSpeech?: string;
  }>;
}> {
  try {
    const languageNames = {
      'en': 'English',
      'es': 'Spanish', 
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese'
    };

    const sourceLangName = languageNames[sourceLanguage as keyof typeof languageNames] || sourceLanguage;
    const targetLangName = languageNames[targetLanguage as keyof typeof languageNames] || targetLanguage;

    const prompt = `Split this ${sourceLangName} text into hoverable segments and translate each meaningful word to ${targetLangName}.

Text: "${text}"

Return ONLY a JSON object with this exact structure:
{
  "segments": [
    {
      "text": "original_word",
      "translation": "translated_word",
      "hoverable": true/false,
      "partOfSpeech": "noun/verb/adjective/etc"
    }
  ]
}

Rules:
- Only make words hoverable if they have clear meaning
- Exclude particles, articles, and grammar words (like "が", "です", "the", "a", "an")
- For languages without spaces (Japanese, Chinese), split into meaningful characters/words
- For languages with spaces, split by words but exclude grammar words
- Be accurate with translations and part of speech`;

    const response = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 500,
      temperature: 0.1,
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response generated by OpenAI');
    }

    const result = JSON.parse(content);
    return result;
  } catch (error) {
    console.error('Split and translate error:', error);
    throw new Error('Failed to split and translate text');
  }
}

// Available languages
export const SUPPORTED_LANGUAGES = [
  { code: 'en', name: 'English', native_name: 'English' },
  { code: 'es', name: 'Spanish', native_name: 'Español' },
  { code: 'fr', name: 'French', native_name: 'Français' },
  { code: 'de', name: 'German', native_name: 'Deutsch' },
  { code: 'it', name: 'Italian', native_name: 'Italiano' },
  { code: 'pt', name: 'Portuguese', native_name: 'Português' },
  { code: 'ru', name: 'Russian', native_name: 'Русский' },
  { code: 'ja', name: 'Japanese', native_name: '日本語' },
  { code: 'ko', name: 'Korean', native_name: '한국어' },
  { code: 'zh', name: 'Chinese', native_name: '中文' },
];
