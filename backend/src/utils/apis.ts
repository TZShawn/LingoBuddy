import axios from 'axios';
import OpenAI from 'openai';

const DEEPGRAM_API_URL = 'https://api.deepgram.com/v1/listen';
const ELEVENLABS_API_URL = 'https://api.elevenlabs.io/v1/text-to-speech';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Deepgram API
export async function transcribeAudio(audioBase64: string, language: string): Promise<string> {
  const audioBuffer = Buffer.from(audioBase64, 'base64');
  
  const languageToVoiceId = {
    'en': {voiceId: 'cgSgspJ2msm6clMCkdW9', gender: 'female', name: 'Alice'},
    'es': {voiceId: 'iyvXhCAqzDxKnq3FDjZl', gender: 'female', name: 'Alice'},
    'fr': {voiceId: 'gaiKXUXMtA8O5fyBjiS9', gender: 'male', name: 'James'},
    'it': {voiceId: 'b8jhBTcGAq4kQGWmKprT', gender: 'female', name: 'Alice'},
    'ja': {voiceId: 'PmgfHCGeS5b7sH90BOOJ', gender: 'femmale', name: 'Alice'},
    'ko': {voiceId: 'AW5wrnG1jVizOYY7R1Oo', gender: 'female', name: 'Alice'},
    'zh': {voiceId: '4VZIsMPtgggwNg7OXbPY', gender: 'male', name: 'James'},
  }

  // Convert language name to language code
  const languageMap: { [key: string]: string } = {
    'English': 'en',
    'Spanish': 'es', 
    'French': 'fr',
    'German': 'de',
    'Italian': 'it',
    'Portuguese': 'pt',
    'Russian': 'ru',
    'Japanese': 'ja',
    'Korean': 'ko',
    'Mandarin (simplified)': 'zh'
  };
  
  const languageCode = language
  
  console.log('Transcribing audio with language:', language, '->', languageCode);
  console.log('Audio buffer size:', audioBuffer.length, 'bytes');
  
  try {
    const response = await axios.post(
      `${DEEPGRAM_API_URL}?model=nova-2&language=${languageCode}&smart_format=true&punctuate=true&utterances=true`,
      audioBuffer,
      {
        headers: {
          'Authorization': `Token ${process.env.DEEPGRAM_API_KEY}`,
          'Content-Type': 'audio/webm',
        },
        timeout: 30000, // 30 second timeout
      }
    );

    console.log('Deepgram response:', JSON.stringify(response.data, null, 2));

    // Check if we have results
    if (!response.data.results) {
      console.error('No results in Deepgram response:', response.data);
      throw new Error('No results found in Deepgram response');
    }

    // Check if we have channels
    if (!response.data.results.channels || response.data.results.channels.length === 0) {
      console.error('No channels in Deepgram response:', response.data);
      throw new Error('No channels found in Deepgram response');
    }

    // Check if we have alternatives
    const alternatives = response.data.results.channels[0].alternatives;
    if (!alternatives || alternatives.length === 0) {
      console.error('No alternatives in Deepgram response:', response.data);
      throw new Error('No alternatives found in Deepgram response');
    }

    const transcript = alternatives[0].transcript;
    if (!transcript || transcript.trim() === '') {
      console.error('Empty transcript in Deepgram response:', response.data);
      throw new Error('No transcript found in Deepgram response');
    }

    console.log('Successfully transcribed:', transcript);
    return transcript;
  } catch (error: any) {
    console.error('Deepgram API error:', error.response?.data || error.message);
    throw new Error(`Deepgram transcription failed: ${error.response?.data?.error || error.message}`);
  }
}

// OpenAI API
export async function chatGenerateResponse(
  userMessage: string,
  language: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }> = [],
  gender: string,
  name: string
): Promise<string> {
  const systemPrompt = `You are a helpful language learning assistant named ${name}. You have the personality of a young adult with gender ${gender} you share very common hobbies and likes as people your age. 
  The user is practicing ${language} and is still learning the language. 
  Respond naturally in ${language} you are meant to be someone to talk to not mention you want to help them improve their language skills.
  You should not have lenghty responses, keep them short and concise.
  Keep responses conversational and encouraging do not use any other language than ${language}. You are not to imitate a machine, you are to interact like a human would`;

  const messages = [
    { role: 'system' as const, content: systemPrompt },
    ...conversationHistory,
    { role: 'user' as const, content: userMessage }
  ];

  const response = await openai.chat.completions.create({
    model: process.env.OPENAI_MODEL || 'gpt-5-nano-2025-08-07',
    messages,
    max_tokens: 200,
    temperature: 0.7,
  });

  const aiResponse = response.choices?.[0]?.message?.content;
  if (!aiResponse) {
    throw new Error('No response generated by OpenAI');
  }

  return aiResponse;
}

// 11Labs API
export async function textToSpeech(text: string, voiceId?: string): Promise<string> {
  const voice = voiceId || process.env.ELEVENLABS_VOICE_ID || 'Xb7hH8YSGvpEDdOyD4ZN'; // Alexandra - young female voice
  
  const response = await axios.post(
    `${ELEVENLABS_API_URL}/${voice}`,
    {
      text,
      model_id: 'eleven_multilingual_v2', // Best quality for 29 languages including all target languages
      voice_settings: {
        stability: 0.5,
        similarity_boost: 0.5,
      },
    },
    {
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': process.env.ELEVENLABS_API_KEY!,
      },
      responseType: 'arraybuffer',
    }
  );

  return Buffer.from(response.data).toString('base64');
}

// OpenAI Translation API
export async function translateWord(
  word: string,
  sourceLanguage: string,
  targetLanguage: string
): Promise<{ translatedWord: string; partOfSpeech?: string; confidence?: number }> {
  try {
    const languageNames = {
      'en': 'English',
      'es': 'Spanish', 
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese'
    };

    const sourceLangName = languageNames[sourceLanguage as keyof typeof languageNames] || sourceLanguage;
    const targetLangName = languageNames[targetLanguage as keyof typeof languageNames] || targetLanguage;

    const prompt = `Translate the word "${word}" from ${sourceLangName} to ${targetLangName}. 
    Return ONLY a JSON object with this exact structure:
    {
      "translatedWord": "translation",
      "partOfSpeech": "noun/verb/adjective/etc",
      "confidence": 0.95
    }
    
    Be concise and accurate. If the word has multiple meanings, provide the most common one.`;

    const response = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 100,
      temperature: 0.1, // Low temperature for consistent results
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response generated by OpenAI');
    }

    // Parse the JSON response
    const translation = JSON.parse(content);
    return {
      translatedWord: translation.translatedWord,
      partOfSpeech: translation.partOfSpeech,
      confidence: translation.confidence || 0.9,
    };
  } catch (error) {
    console.error('Translation error:', error);
    throw new Error('Failed to translate word');
  }
}

// OpenAI Text Splitting and Translation API
export async function splitAndTranslateText(
  text: string,
  sourceLanguage: string,
  targetLanguage: string
): Promise<{
  segments: Array<{
    text: string;
    translation: string;
    hoverable: boolean;
    partOfSpeech?: string;
  }>;
}> {
  try {
    const languageNames = {
      'en': 'English',
      'es': 'Spanish', 
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'pt': 'Portuguese',
      'ru': 'Russian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese'
    };

    const sourceLangName = languageNames[sourceLanguage as keyof typeof languageNames] || sourceLanguage;
    const targetLangName = languageNames[targetLanguage as keyof typeof languageNames] || targetLanguage;

    console.log('Splitting and translating text:', text, sourceLangName, targetLangName);

    const prompt = `Split this ${sourceLangName} text into hoverable segments and translate each meaningful word to ${targetLangName}.

Text: "${text}"

Return ONLY a JSON object with this exact structure:
{
  "textTranslation": "whole_text_translation",
  "segments": [
    {
      "text": "original_word",
      "translation": "translated_word",
      "hoverable": true/false,
      "partOfSpeech": "noun/verb/adjective/etc"
    }
  ]
}

Rules:
- You need to make sure you split and translate in a way that people can hover over individual segments and make out what the overall text means. 
- Make sure you take in the context of the text and split accordingly. For example if two words together have a meaning but separted they mean other stuff you should try to keep them together if the context makes more sense. 
- Exclude particles, articles, and grammar words (like "が", "です", "the", "a", "an")
- For languages without spaces (Japanese, Chinese), split into meaningful characters/words
- For languages with spaces, split by words but exclude grammar words
- Be accurate with translations and part of speech`;

    const response = await openai.chat.completions.create({
      model: process.env.OPENAI_MODEL || 'gpt-5-mini-2025-08-07',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 4096,
      temperature: 0.1,
    });

    const content = response.choices?.[0]?.message?.content;
    if (!content) {
      throw new Error('No response generated by OpenAI');
    }

    console.log('Split and translate text response:', content.slice(-300));

    const result = JSON.parse(content);
    return result;
  } catch (error) {
    console.error('Split and translate error:', error);
    throw new Error('Failed to split and translate text');
  }
}

// Available languages
export const SUPPORTED_LANGUAGES = [
  { code: 'en', name: 'English', native_name: 'English' },
  { code: 'es', name: 'Spanish', native_name: 'Español' },
  { code: 'fr', name: 'French', native_name: 'Français' },
  { code: 'de', name: 'German', native_name: 'Deutsch' },
  { code: 'it', name: 'Italian', native_name: 'Italiano' },
  { code: 'pt', name: 'Portuguese', native_name: 'Português' },
  { code: 'ru', name: 'Russian', native_name: 'Русский' },
  { code: 'ja', name: 'Japanese', native_name: '日本語' },
  { code: 'ko', name: 'Korean', native_name: '한국어' },
  { code: 'zh', name: 'Chinese', native_name: '中文' },
];
